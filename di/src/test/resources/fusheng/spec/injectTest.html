<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Inject</title>
</head>
<body>

<h3>例子1：构造函数存在简单依赖</h3>
<div class="example">
    <span class="function" data-action="initContainer">初始化一个容器</span>，
    将类<span class="variable" data-name="className">Bar</span>
    <span class="function" data-action="registerClass" data-params="className">注册到容器中</span>，
    Bar 类的代码如下，其构造函数存在对 Foo 类的依赖，这里可以用 @Inject 注解修饰这个构造函数，同时注意这个构造函数不必是 public 的
    <pre><code>
        public class Bar {
            private Foo foo;

            public Foo getFoo() {
                return foo;
            }

            @Inject
            Bar(Foo foo) {
                this.foo = foo;
            }
        }
    </code></pre>

    然后将其的依赖项<span class="variable" data-name="classNameForDependency">Foo</span>也
    <span class="function" data-action="registerClass" data-params="classNameForDependency">注册到容器中</span>

    <pre><code>
        container.register(Foo.class);
    </code></pre>

    当通过
    容器<span class="function" data-action="getInstance" data-params="className" data-return="instance">实例化</span>
    Bar 类的时候
    <pre><code>
        container.getInstance(Bar.class);
    </code></pre>
    容器会试图从其托管的类中寻找 Bar 所需的依赖，并调用对应的构造方法，
    最终可以获得正确注入了依赖
    <span class="assertion" data-action="getClassName" data-expect="equal" data-params="instance.getFoo()">Foo</span>
    的 Bar 实例
</div>

<h3>例子2：构造函数存在循环依赖</h3>
<div class="example">
    <span class="function" data-action="initContainer">初始化一个容器</span>，
    将类<span class="variable" data-name="className">Circus</span>
    <span class="function" data-action="registerClass" data-params="className">注册到容器中</span>，
    Circus 类的代码如下，其@Inject修饰的构造函数存在对 Circus 类自身的循环依赖
    <pre><code>
        public class Circus {
            private Circus circus;

            @Inject
            Circus(Circus circus) {
                this.circus = circus;
            }
        }
    </code></pre>

    当通过容器实例化
    <span class="variable" data-name="className">Circus</span>
    类的时候
    <pre><code>
        container.getInstance(Circus.class);
    </code></pre>
    容器会抛出
    <span class="assertion" data-action="getInstanceWithCircularDependency"
          data-expect="equal" data-params="className">CreateInstanceFailedException</span>
    异常
</div>

</body>
</html>