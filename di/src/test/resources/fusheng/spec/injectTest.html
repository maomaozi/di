<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<h3>例子1：构造函数存在简单依赖</h3>
<div class="example">
    <span class="function" data-action="initContainer">初始化一个容器</span>，
    将类<span class="variable" data-name="className">Bar</span>
    <span class="function" data-action="registerClass" data-params="className">注册到容器中</span>，
    Bar 类的代码如下，其构造函数存在对 Foo 类的依赖，这里可以用 @Inject 注解修饰这个构造函数，同时注意这个构造函数不必是 public 的
    <pre><code>
        public class Bar {
            private Foo foo;

            public Foo getFoo() {
                return foo;
            }

            @Inject
            Bar(Foo foo) {
                this.foo = foo;
            }
        }
    </code></pre>

    然后将其的依赖项<span class="variable" data-name="classNameForDependency">Foo</span>也
    <span class="function" data-action="registerClass" data-params="classNameForDependency">注册到容器中</span>

    <pre><code>
        container.register(Foo.class);
    </code></pre>

    当通过
    <span class="function" data-action="getInstanceFromContainer" data-params="className">容器实例化</span>
    Bar类的时候
    <pre><code>
        container.getInstance(Bar.class);
    </code></pre>
    容器会试图从其托管的类中寻找 Bar 所需的依赖，并调用对应的构造方法，
    最终可以获得正确注入了依赖
    <span class="assertion" data-action="tryGetDependencyNameInBar" data-expect="equal">Foo</span>
    的 Bar 实例
</div>

</body>
</html>