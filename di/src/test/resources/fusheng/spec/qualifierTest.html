<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Qualifier</title>
</head>
<body>

<h3>例子1：使用 @Qualifier 指明具体的实现类</h3>
<div class="example">

    <span class="function" data-action="initContainer">初始化一个容器</span>，
    将类<span class="variable" data-name="className">Car,Engine,GasEngine,DieselEngine</span>
    <span class="function" data-action="registerClasses" data-params="className">注册到容器中</span>，
    Car 类的代码如下
    <pre><code>
        public class Car {
            private final Engine engine;

            @Inject
            public Car(@Gas Engine engine) {
                this.engine = engine;
            }

            public String getEngineName() {
                return engine.getName();
            }
        }
    </code></pre>

    其存在对于 Engine 接口的依赖， Engine 的实现有两个，分别是

    <pre><code>
        @Gas
        public class GasEngine implements Engine {
            private static final String name = "Gas";

            @Override
            public String getName() {
                return name;
            }
        }
    </code></pre>

    以及

    <pre><code>
        @Diesel
        public class DieselEngine implements Engine {
            private static final String name = "Diesel";

            @Override
            public String getName() {
                return name;
            }
        }
    </code></pre>

    如上所示，可以在注入的时候，利用 @Qualifier 构建新的注解，

    <pre><code>
        @Documented
        @Retention(RetentionPolicy.RUNTIME)
        @Qualifier
        public @interface Gas {
        }
    </code></pre>

    <pre><code>
        @Documented
        @Retention(RetentionPolicy.RUNTIME)
        @Qualifier
        public @interface Diesel {
        }
    </code></pre>

    然后用这些注解标注对应的具体实现类，从而
    <span class="function" data-action="getInstance" data-params="className" data-return="car">
        通过容器获取到 <span class="variable" data-name="className">Car</span> 的实例后
    </span>，
    调用其 getEngineName 方法可以成功取得 engine 类型为
    <span class="assertion" data-actual="car.getEngineName()" data-expect="equal">Gas</span>

</div>

<h3>例子2：使用带属性的 @Qualifier 指明具体的实现类</h3>
<div class="example">

    <span class="function" data-action="initContainer">初始化一个容器</span>，
    将类<span class="variable" data-name="className">Bike,Wheel,BigWheel,SmallWheel</span>
    <span class="function" data-action="registerClasses" data-params="className">注册到容器中</span>，
    Bike 类的代码如下
    <pre><code>
        public class Bike {

            private final Wheel wheel;

            @Inject
            public Bike(@WheelType(type = BIG) Wheel wheel) {
                this.wheel = wheel;
            }

            public String getWheelType() {
                return wheel.getType();
            }
        }
    </code></pre>

    其存在对于 Wheel 接口的依赖， Wheel 的实现有两个，分别是

    <pre><code>
        @WheelType(type = WheelType.Type.BIG)
        public class BigWheel implements Wheel {
            private static final String name = "Big";

            @Override
            public String getType() {
                return name;
            }
        }
    </code></pre>

    以及

    <pre><code>
        @WheelType(type = WheelType.Type.SMALL)
        public class SmallWheel implements Wheel {
            private static final String name = "Small";

            @Override
            public String getType() {
                return name;
            }
        }
    </code></pre>

    WheelType注解的相关代码如下，其中包括一个枚举，定义了 BIG 和 SMALL 两种 Wheel 尺寸

    <pre><code>
        @Documented
        @Retention(RetentionPolicy.RUNTIME)
        @Qualifier
        public @interface WheelType {
            Type type() default Type.SMALL;

            enum Type {
                BIG, SMALL
            }
        }
    </code></pre>

    <span class="function" data-action="getInstance" data-params="className" data-return="bike">
        通过容器获取到 <span class="variable" data-name="className">Bike</span> 的实例后
    </span>，
    调用其 getWheel 方法可以成功取得 Wheel 类型为
    <span class="assertion" data-actual="bike.getWheelType()" data-expect="equal">Big</span>

</div>

<h3>例子3：使用 @Named 指明具体的实现类</h3>
<div class="example">

    <span class="function" data-action="initContainer">初始化一个容器</span>，
    将类<span class="variable" data-name="className">MotoBike,Wheel,BigWheel,SmallWheel</span>
    <span class="function" data-action="registerClasses" data-params="className">注册到容器中</span>，
    MotoBike 类的代码如下
    <pre><code>
        public class MotoBike {

            private final Wheel wheel;

            @Inject
            public MotoBike(@Named("smallWheel") Wheel wheel) {
                this.wheel = wheel;
            }

            public String getWheelType() {
                return wheel.getType();
            }
        }
    </code></pre>

    其存在对于 Wheel 接口的依赖，并且使用 @Named("smallWheel") 注解指明了Wheel的实现，对应Wheel的实现类上也有相同的注解

    <span class="function" data-action="getInstance" data-params="className" data-return="motoBike">
        通过容器获取到 <span class="variable" data-name="className">MotoBike</span> 的实例后
    </span>，
    调用其 getWheel 方法可以成功取得 Wheel 类型为
    <span class="assertion" data-actual="motoBike.getWheelType()" data-expect="equal">Small</span>

</div>
</body>
</html>