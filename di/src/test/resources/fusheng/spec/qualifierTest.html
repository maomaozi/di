<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Qualifier</title>
</head>
<body>

<h2>3. 使用 @Qualifier 注解表明类的具体实现</h2>

<h3>例子1：使用 @Qualifier 来注入一个接口的实现类</h3>
<div class="example">

    现在有一个 Car 类，它的构造方法依赖 Engine 接口，
    <p></p>
    Car 的代码如下
    <pre><code>
        public class Car {
            private final Engine engine;

            @Inject
            public Car(@Gas Engine engine) {
                this.engine = engine;
            }

            public String getEngineName() {
                return engine.getName();
            }
        }
    </code></pre>

    而对于 Engine 接口的具体实现有两个，分别是 GasEngine 和 DieselEngine

    <pre><code>
        @Gas
        public class GasEngine implements Engine {
            private static final String name = "Gas";

            @Override
            public String getName() {
                return name;
            }
        }
    </code></pre>

    以及

    <pre><code>
        @Diesel
        public class DieselEngine implements Engine {
            private static final String name = "Diesel";

            @Override
            public String getName() {
                return name;
            }
        }
    </code></pre>

    这时候，可以通过 @Qualifier 构建衍生的注解来指明当前具体想要实例化的实现

    例如
    <pre><code>
        @Documented
        @Retention(RetentionPolicy.RUNTIME)
        @Qualifier
        public @interface Gas {
        }
    </code></pre>

    <pre><code>
        @Documented
        @Retention(RetentionPolicy.RUNTIME)
        @Qualifier
        public @interface Diesel {
        }
    </code></pre>
    是两个新的注解，上面都有 @Qualifier，这两个注解分别指定了 Gas 和 Diesel，然后如前面代码所示，使用 @Gas 注解分别标注实现类和注入点

    然后<span class="function" data-action="initContainer">初始化一个容器</span>，
    将类<span class="variable" data-name="className">Car,Engine,GasEngine,DieselEngine</span>
    <span class="function" data-action="registerClasses" data-params="className">全部注册到容器中</span>，

    <span class="function" data-action="getInstance" data-params="className" data-return="car">
        从而通过容器 getInstance 方法获取到 <span class="variable" data-name="className">Car</span> 的实例后，
    </span>
    Car 的实例中的 Engine 实际的对象是一个 GasEngine
    通过调用其 getEngineName 方法可以成功取得 engine 类型为
    <span class="assertion" data-actual="car.getEngineName()" data-expect="equal">Gas</span>

</div>

<h3>例子2：使用带属性的 @Qualifier 指明具体的实现类</h3>
<div class="example">

    类似于第一个例子，这次构建一个关于 Bike 类的例子
    <p></p>
    Bike 类的代码如下：
    <pre><code>
        public class Bike {

            private final Wheel wheel;

            @Inject
            public Bike(@WheelType(type = BIG) Wheel wheel) {
                this.wheel = wheel;
            }

            public String getWheelType() {
                return wheel.getType();
            }
        }
    </code></pre>

    其存在对于 Wheel 接口的依赖， Wheel 的实现有两个，分别是

    <pre><code>
        @WheelType(type = WheelType.Type.BIG)
        public class BigWheel implements Wheel {
            private static final String name = "Big";

            @Override
            public String getType() {
                return name;
            }
        }
    </code></pre>

    以及

    <pre><code>
        @WheelType(type = WheelType.Type.SMALL)
        public class SmallWheel implements Wheel {
            private static final String name = "Small";

            @Override
            public String getType() {
                return name;
            }
        }
    </code></pre>

    WheelType注解的相关代码如下，其中包括一个枚举，定义了 BIG 和 SMALL 两种 Wheel 尺寸

    <pre><code>
        @Documented
        @Retention(RetentionPolicy.RUNTIME)
        @Qualifier
        public @interface WheelType {
            Type type() default Type.SMALL;

            enum Type {
                BIG, SMALL
            }
        }
    </code></pre>

    在前面的 Bike 类的代码中，我们用 @WheelType(type = BIG) 标注了具体需要注入的 Wheel类型

    接下来<span class="function" data-action="initContainer">初始化一个容器</span>，
    将类<span class="variable" data-name="className">Bike,Wheel,BigWheel,SmallWheel</span>
    <span class="function" data-action="registerClasses" data-params="className">全部注册到容器中</span>，

    <span class="function" data-action="getInstance" data-params="className" data-return="bike">
        通过容器获取到 <span class="variable" data-name="className">Bike</span> 的实例后
    </span>，
    调用其 getWheel 方法可以成功取得 Wheel 类型为
    <span class="assertion" data-actual="bike.getWheelType()" data-expect="equal">Big</span>

</div>

<h3>例子3：使用 @Named 指明具体的实现类</h3>
<div class="example">

    @Named 是 JSR-330 中要求的，一个框架中已经实现的 @Qualified 衍生注解，他只有一个字符串的 value 属性，其作用和用户自定义的 @Qualified 衍生注解没有区别

    <p></p>

    例如，对于如下的一个 MotoBike 类：

    <pre><code>
        public class MotoBike {

            private final Wheel wheel;

            @Inject
            public MotoBike(@Named("smallWheel") Wheel wheel) {
                this.wheel = wheel;
            }

            public String getWheelType() {
                return wheel.getType();
            }
        }
    </code></pre>

    其存在对于 Wheel 接口的依赖，并且使用 @Named("smallWheel") 注解指明了Wheel的实现，对应 Wheel 的实现类上也有相同的注解

    <span class="function" data-action="initContainer">初始化一个容器</span>，
    将类<span class="variable" data-name="className">MotoBike,Wheel,BigWheel,SmallWheel</span>
    <span class="function" data-action="registerClasses" data-params="className">注册到容器中</span>，

    <span class="function" data-action="getInstance" data-params="className" data-return="motoBike">
        通过容器获取到 <span class="variable" data-name="className">MotoBike</span> 的实例后
    </span>，
    调用其 getWheel 方法可以成功取得 Wheel 类型为
    <span class="assertion" data-actual="motoBike.getWheelType()" data-expect="equal">Small</span>

</div>
</body>
</html>