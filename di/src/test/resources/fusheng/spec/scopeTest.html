<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Scope</title>
</head>
<body>

<h3>例子1：使用 Singleton 来使得托管类为单例</h3>
<div class="example">
    <span class="function" data-action="initContainer">初始化一个容器</span>，
    将类<span class="variable" data-name="className">Buzz</span>
    <span class="function" data-action="registerClass" data-params="className">注册到容器中</span>，
    Buzz 类的代码如下，其构造函数存在对 Foo 类的依赖，这里用 @Singleton 注解修饰构造方法的Foo
    <pre><code>
        public class Buzz {
            private final Foo foo;

            @Inject
            Buzz(@Singleton Foo foo) {
                this.foo = foo;
            }

            public Foo getFoo() {
                return foo;
            }
        }
    </code></pre>

    <span class="function" data-action="registerClass" data-params="className">
        然后注册其依赖项
        <span class="variable" data-name="className">Foo</span>
        到容器中
    </span>

    <pre><code>
        container.register(Foo.class);
    </code></pre>

    然后从容器
    <span class="function" data-action="getInstance" data-params="className" data-return="buzz1">
        实例化第一个
        <span class="variable" data-name="className">Buzz</span>
        实例
    </span>，

    <span class="function" data-action="getInstance" data-params="className" data-return="buzz2">
        接下来再实例化一个
        <span class="variable" data-name="className">Buzz</span>
        实例
    </span>，

    <span class="assertion" data-actual="buzz1 === buzz2" data-expect="false">
        最终两个 Buzz 实例地址并不相等
    </span>
    <span class="assertion" data-actual="buzz1.getFoo() === buzz2.getFoo()" data-expect="true">
        但是两个 Buzz 中的两个 Foo 实例地址相等
    </span>
</div>

</body>
</html>